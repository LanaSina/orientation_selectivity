---
title: "filter_analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Setup 

```{r}
#install.packages("gplots")
library(gplots) 
#install.packages("tidyr")
library(tidyr) 
require(ggplot2)
#install.packages("reshape2")
library(reshape2)
library(ggplot2)
library(tidyr)

folderName = "/Users/lana/Development/SNET_data/"
```
Read prediction matrix for single pixel predictions

useful functions
```{r}

#calculate average influence by distance in same grayscale for several neurons
averageByDistance = function(side, ids){
  #just to calculate maxDist
  maxDist = sqrt(2*side*side)
  n = floor(maxDist+1)
  pd = rep(0,n)

  for(nId in ids){
    gscale = floor(nId/nInGrayscale)
    avMatrix = averageInfluence(side, nId,gscale,gscale)
    
    k = nId%%nInGrayscale 
    y = floor(k/side)
    x = k%%side
    pointData = data.frame(x=x, y=y)
    temp = predictabilityByDistance(side, avMatrix,pointData)
    pd = pd + temp
  }
  
  pd = pd/length(ids)
  return(pd)
}


#print influence relative to distance
predictabilityByDistance = function(side, predictionMatrix, pointData){
  maxDist = sqrt(2*side*side) 
  n = floor(maxDist+1)
  avPredictions = rep(0,n)
  pointsCount = rep(0,n)
  
  rows = length(predictionMatrix[,1]) 
  cols = length(predictionMatrix[1,]) 
  
  for(i in 1:rows){
    for(j in 1:cols){
      d = sqrt((pointData$x - j)^2 + (pointData$y - i)^2)
      avPredictions[floor(d)] = avPredictions[floor(d)]+predictionMatrix[i,j] 
      pointsCount[floor(d)] = pointsCount[floor(d)] + 1
    }
  }
  
  avPredictions = avPredictions/pointsCount
  avPredictions[is.na(avPredictions)] <- 0
  return(avPredictions)
}


#average on several grayscales
averageInfluence = function(side, nId, scaleStart, scaleStop){
  sumMatrix = matrix(data=rep(0,side*side), nrow=side, ncol=side, byrow = TRUE)
  sub = subset(weights, from_neuron==nId)
  
  for(toGrayscale in scaleStart:scaleStop){
    #cut by grayscale
    scale = subset(sub, (to_neuron>=(nInGrayscale*toGrayscale)) &
                     (to_neuron<(nInGrayscale*(toGrayscale+1)))
    )
    startId =  nInGrayscale*toGrayscale
    
    if(length(scale$to_neuron)!=0){
      scale = subset(scale, weight_age!=0)
      orderedScale = scale[order(scale$to_neuron),]
      
      #fill missing values
      zeroes = data.frame(to_neuron=c(startId:(startId + nInGrayscale -1)))#, p=rep(0,nInGrayscale)
      filled <- merge(orderedScale, zeroes, all=TRUE)
      filled[is.na(filled)] <- 0
      
      #cut by position
      field = matrix(data=filled$p, nrow=side, ncol=side, byrow = TRUE)
      field = field[1:side,]
      
      sumMatrix = sumMatrix+field
    }
  }
  
  return(sumMatrix/(scaleStop-scaleStart+1.0))
}

```

Calculate, save, and display prediction = f(distance)
```{r}
 
folderName = "/Users/lana/Development/SNET_data/single_pixel_prediction/"
experiment = "CROPPED_OSWALD_9/"
fileName = paste(folderName, experiment, "prediction_weights.csv", sep = "")

print(fileName)
df = read.csv(fileName)
weights = df
weights$p = weights$weight_value / weights$weight_age
#sanity check
length(subset(weights,p>1)$p)

side = 50 #image size
nInGrayscale = side*side
ids = unique(weights$from_neuron)

#p = f(d) for all neurons
avPd = averageByDistance(side, ids)
plot(avPd, type = "l",
     xlab = "Distance (pixels)", ylab = "Predictive power",
     ylim = c(0,1)
     )
filename =  paste(folderName, experiment, "averagedPredictionByDistance.csv", sep="")
print(filename)
write.csv(avPd, filename)

```

Save the plot as clean pdf

```{r}
filename = paste(folderName, experiment, "single_pixel_greyscale.pdf", sep = "")
print(filename)
pdf(filename, width=4, height=4) 
plot(avPd, type = "l",
     xlab = "Distance (pixels)", ylab = "Predictive power",
     ylim = c(0,1)
     )
# Close the pdf file
dev.off() 

```

Process data for filter-based prediction

Useful functions

```{r}

allOrientationsByDistance = function(weights, direction, filterPosition){
  maxSize = max(weights[[direction]])
  horizontalW = subset(weights, filterId == 0)
  verticalW = subset(weights, filterId == 1)
  randomW = subset(weights, filterId == 2)
  fullW = subset(weights, filterId == 3)
  np = filterPosition
  
  verticalWd = meanByDistance(verticalW, direction, np, maxSize)
  horizontalWd = meanByDistance(horizontalW, direction, np, maxSize)
  fullWd = meanByDistance(fullW,"neuron_x", np, maxSize)
  randomWd = meanByDistance(randomW, direction, np, maxSize)
  
  result = data.frame(distance = verticalWd$distance,
                      horizontal = horizontalWd$p,
                      vertical = verticalWd$p,
                      full = fullWd$p, random = randomWd$p)
  
  return(result)
}

#param axis: string "neuron_x" or "neuron_y"
#param origin = middle of the filter for that axis
meanByDistance = function(subWeights, axis, origin, maxSize){
  #maxSize = length(subWeights$p)
  subWeights = sortByDistance(subWeights, axis, origin)
  
  instances = rep(0, maxSize)
  result = data.frame(distance = c(0:(maxSize-1)), p = rep(0, maxSize))
  for(i in 1:maxSize){
    sub = subset(subWeights, distance==i-1)
    instances[i] = instances[i] + length(sub$p)
    result$p[i] = result$p[i] + sum(sub$p)
  }
  
  result$p = result$p/instances
  result$p[is.na(result$p)] <- 0
  
  return(result)
}

sortByDistance = function(weights, axis, origin){
  result = weights
  result$distance = abs(result[[axis]] - origin)
  result = result[order(result$distance),]
  return(result)
}

plotProbas = function(probas){
  
  plot(probas$distance, probas$vertical, type = "l",
       ylim = c(0,1), xlim = c(0,50),
       xlab = "Distance (pixels)", ylab = "Predictive power"
       )
  points(probas$distance, probas$horizontal, type = "l", col = "red")
  points(probas$distance, probas$full, type = "l", col = "blue")
  points(probas$distance, probas$random, type = "l", col = "green")
  legend(25, 1, legend=c("Vertical filter", "Horizontal filter", "Random filter", "Full filter"),
       col=c("red", "blue"), lty=1:2, cex=0.8)
}

```

Read one set of filters
```{r}
d = "v"

configuration = "filter_prediction/contrast/OSWALD_20FPS"
filterFolder = "x_376_y_277/"
direction = "neuron_x"
subfolder = "/horizontal/"
if(d=="v"){
  direction = "neuron_y"
  subfolder = "/vertical/"
}
experiment = paste(folderName,configuration,subfolder,filterFolder,sep = "")
fileName = paste(experiment, "filter_weights.csv", sep = "")
print(fileName)
df = read.csv(fileName)
weights = df
weights$p = weights$value / weights$age
weights$p[is.na(weights$p)] <- 0
maxAge = max(weights$age)
print(maxAge)
#sanity check
length(subset(weights,age>0)$p)


fileName = paste(experiment, "filters.csv", sep = "")
print(fileName)
df = read.csv(fileName)
filters = df
```



Plot weights depending on distance

```{r}

horizontalW = subset(weights, filterId == 0)
verticalW = subset(weights, filterId == 1)
randomW = subset(weights, filterId == 2)
fullW = subset(weights, filterId == 3)

fileName = paste(experiment, "/filter_configuration.csv", sep = "")
print(fileName)
df = read.csv(fileName)
print(df)
conf = df
if(direction=="neuron_x"){
  np = conf$fx[1] + 1 #middle of filter
} else {
  np = conf$fy[1] + 1
}

maxSize = max(weights[[direction]])


verticalWd = meanByDistance(verticalW, direction, np, maxSize)
horizontalWd = meanByDistance(horizontalW, direction, np, maxSize)
fullWd = meanByDistance(fullW,"neuron_x", np, maxSize)
randomWd = meanByDistance(randomW, direction, np, maxSize)

l = max(horizontalW[[direction]])
allProbas = data.frame(distance = c(0:(l-1)), vertical = rep(0, l), horizontal = rep(0, l),
                       random = rep(0, l), full = rep(0, l))
allProbas$distance = verticalWd$distance
allProbas$vertical = verticalWd$p
allProbas$horizontal = horizontalWd$p
allProbas$full = fullWd$p
allProbas$random = randomWd$p

plotProbas(probas = allProbas)

#plot(verticalW$neuron_y,verticalW$p, type = "l")
#plot(verticalWd$distance, verticalWd$p, type = "l")
```


Read a set of filters

```{r}
d = "h"
configuration = "filter_prediction/contrast/OSWALD_20FPS"

direction = "neuron_x"
subfolder = "/horizontal/"
if(d=="v"){
  direction = "neuron_y"
  subfolder = "/vertical/"
}

folders <- list.dirs(path=paste(folderName, configuration, subfolder, sep=""),
                    full.names=TRUE, recursive=FALSE)
allWeights = list()
allFilterPositions = list()
i = 0
for(experiment in folders){
  i = i+1
  fileName = paste(experiment, "/filter_weights.csv", sep = "")
  print(fileName)
  df = read.csv(fileName)
  weights = df
  weights$p = weights$value / weights$age
  weights$p[is.na(weights$p)] <- 0
  allWeights[[i]] = weights
  
  fileName = paste(experiment, "/filter_configuration.csv", sep = "")
  df = read.csv(fileName)
  conf = df
  if(direction=="neuron_x"){
    np = conf$fx[1] + 1 #middle of filter
  } else {
    np = conf$fy[1] + 1
  }
  allFilterPositions[[i]] = np
}

#experiment = folders[1]
```

Aggreagte and plot weights depending on distance

```{r}
l = max(allWeights[[1]][[direction]])
allProbas = data.frame(distance = c(0:(l-1)), vertical = rep(0, l), horizontal = rep(0, l),
                       random = rep(0, l), full = rep(0, l))

n = 3 #length(allWeights)

#make lists
vertical = matrix(0,l,n)
horizontal = matrix(0,l,n)
full = matrix(0,l,n)
random = matrix(0,l,n)
for(i in c(1:n)){
  temp = allOrientationsByDistance(allWeights[[i]], direction, allFilterPositions[[i]])
  vertical[,i] = temp$vertical
  horizontal[,i] = temp$horizontal
  full[,i] = temp$full
  random[,i] = temp$random
  
  # allProbas$vertical = allProbas$vertical + temp$vertical
  # allProbas$horizontal = allProbas$horizontal + temp$horizontal
  # allProbas$full = allProbas$full + temp$full
  # allProbas$random = allProbas$random + temp$random
}

#standard error = sd / sqrt(n)
allProbas$distance = temp$distance
allProbas$vertical = rowMeans(vertical)
allProbas$vertical_sd = apply(vertical,1,sd)/sqrt(n)
allProbas$horizontal = rowMeans(horizontal)
allProbas$horizontal_sd = apply(horizontal,1,sd)/sqrt(n)
allProbas$full = rowMeans(full)
allProbas$full_sd = apply(full,1,sd)/sqrt(n)
allProbas$random = rowMeans(random)
allProbas$randoml_sd = apply(random,1,sd)/sqrt(n)

# allProbas$vertical = allProbas$vertical/n
# allProbas$horizontal = allProbas$horizontal/n
# allProbas$full = allProbas$full/n
# allProbas$random = allProbas$random/n

#plotProbas(allProbas)

```


Save figure as pdf
```{r}

filename = paste(folderName, configuration, subfolder, "filters_contrast.pdf", sep = "")
print(filename)
pdf(filename, width=6, height=4)

ggplot(allProbas, aes(distance)) +
       geom_line(aes(y = vertical, colour = "red")) +
       geom_ribbon(aes(ymin = vertical - vertical_sd,
                       ymax = vertical + vertical_sd), alpha = 0.2) +
       xlim(0, 50)

# Close the pdf file
dev.off()

probaLong <- melt(allProbas, id="distance")

ggplot(allProbas, aes(x = distance, y = vertical)) +
       geom_line(color = "red") +
       geom_ribbon(aes(ymin = vertical - vertical_sd,
                       ymax = vertical + vertical_sd), alpha = 0.2) +
       xlim(0, 50)

ggplot(allProbas, aes(distance)) +
       geom_line(aes(y = vertical, colour = "black")) +
       geom_ribbon(aes(ymin = vertical - vertical_sd,
                       ymax = vertical + vertical_sd), alpha = 0.2) +
       geom_line(aes(y = horizontal, colour = "red")) +
       geom_ribbon(aes(ymin = horizontal - horizontal_sd,
                       ymax = horizontal + horizontal_sd), alpha = 0.2) +
       geom_line(aes(y = horizontal, colour = "red")) +
       geom_ribbon(aes(ymin = horizontal - horizontal_sd,
                       ymax = horizontal + horizontal_sd), alpha = 0.2) +
       geom_line(aes(y = horizontal, colour = "red")) +
       geom_ribbon(aes(ymin = horizontal - horizontal_sd,
                       ymax = horizontal + horizontal_sd), alpha = 0.2) +
       xlim(0, 50)

# ses <- dat$CO2 + outer(dat$Standard_error, c(1,-1))
# with(allProbas, 
#   plot(
#     distance, vertical, type="l", ylim=range(ses),
#     panel.first=polygon(c(Age,rev(Age)), c(ses[,1],rev(ses[,2])),border=NA, col="#ebebeb")
#   )
# )

```



Drafts 
```{r}
plot(verticalW[[direction]], verticalW$p, type = "l", ylim = c(0,1))
points(horizontalW[[direction]], horizontalW$p, type = "l", col = "red")
points(fullW[[direction]], fullW$p, type = "l", col = "blue")
randomWd = meanByDistance(randomW, direction, np)
points(randomW[[direction]], randomW$p, type = "l", col = "green")
#abline(v=np)
```

```{r}
plot(x=verticalW[[direction]], y=verticalW$p,type = "l")
points(x=horizontalW[[direction]], y=horizontalW$p,type = "l", col = "red")
points(randomW[[direction]], randomW$p, type = "l", col = "green")
#abline(v=301)
```


Plot weights of horizontal/vertical filters

```{r}
#select weights of horizontal/vertical filters
#all "majority vertical" filters
vWeights = data.frame(filterId=NULL, p=NULL)
for(i in c(1:length(weights$filterId))){
  fId = weights$filterId[i]
  sub = subset(filters, filterId==fId)
  if((sub$x[1]==sub$x[2]) 
     || (sub$x[1]==sub$x[3])
     || (sub$x[2]==sub$x[3])
  ){
    if((sub$y[1]!=sub$y[2]) #exclude ambiguous orientations
       & (sub$y[1]!=sub$y[3])
       & (sub$y[2]!=sub$y[3])
    ){
      weight = weights[i,]
      weightedWeight = weight$p*(weight$age/maxAge)
      temp = data.frame(filterId=fId, p=weightedWeight)
      vWeights = rbind(vWeights,temp)
    }
  }
}
#majority horizontal
hWeights = data.frame(filterId=NULL, p=NULL)
for(i in c(1:length(weights$filterId))){
  fId = weights$filterId[i]
  sub = subset(filters, filterId==fId)
  if((sub$y[1]==sub$y[2]) 
     || (sub$y[1]==sub$y[3])
     || (sub$y[2]==sub$y[3])
  ){
    if((sub$x[1]!=sub$x[2]) #exclude ambiguous orientations
       & (sub$x[1]!=sub$x[3])
       & (sub$x[2]!=sub$x[3])
    ){
      weight = weights[i,]
      weightedWeight = weight$p*(weight$age/maxAge)
      temp = data.frame(filterId=fId, p=weightedWeight)
      hWeights = rbind(hWeights,temp)
    }
  }
}
plot(vWeights$p, type="l", ylim = c(0,1))
print(mean(vWeights$p))
print(sqrt(var(vWeights$p)))
points(hWeights$p, type="l", col = "red")
print(mean(hWeights$p))
#standard devaiation
print(sqrt(var(hWeights$p)))
```

Plot weights in function of centering

```{r}

vWeightsCentering = centeringMatrixWeights(0)
plot(vWeightsCentering[1,], type="l", ylim = c(0,1), col="blue")
points(vWeightsCentering[2,], type="l", col="red")
points(vWeightsCentering[3,], type="l", col="black")

hWeightsCentering = centeringMatrixWeights(1)
plot(hWeightsCentering[1,], type="l", ylim = c(0,1), col="blue")
points(hWeightsCentering[2,], type="l", col="red")
points(hWeightsCentering[3,], type="l", col="black")



```


Functions

```{r}
#param orientation == 0 for vertical, 1 for horizontal centering
#return
#row = which filter-column we are considering
#column = number of cells in that filter-column
#value = p
centeringMatrixWeights = function(orientation){
  centering = matrix(0,filterSize,filterSize)
  counts = matrix(0,filterSize,filterSize)
  for(l in 1:length(weights$filterId)){
    fId = weights$filterId[l]
    sub = subset(filters, filterId==fId)
    #build matrix
    filter = matrix(0, filterSize, filterSize)
    for(i in 1:filterSize){
      if(orientation==0){
        filter[sub$x[i]+1,sub$y[i]+1] = 1 #inverted x and y to transpose filter
      } else {
        filter[sub$y[i]+1,sub$x[i]+1] = 1
      }
    }
    #sum row by row
    rSums = apply(filter,1,sum)
    #sum col by col
    cSums = apply(filter,2,sum)
    
    #exclude ambiguous orientations: majority alignment
    threshold = (filterSize/2)+0.5
    vInclude = cSums>=threshold
    hInclude = rSums>=threshold
    if(!any(vInclude)){
      if(any(hInclude)){
        weight = weights[l,]
        
        for(i in 1:length(rSums)){
          #i is the filter-column or filter-row, 
          # sums[i] is the number of cells belonging to it
          if(rSums[i]>0){
            weightedWeight = weight$p*(weight$age/maxAge)
            centering[i,rSums[i]] = centering[i,rSums[i]] + weightedWeight
            counts[i,rSums[i]] = counts[i,rSums[i]]+ 1
          }
        }
        weightsCentering = centering/counts
      }
    }
  }
  return(weightsCentering)
}
```

